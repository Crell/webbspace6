<?php

/**
 * @file
 *   Adds a "Character" widget to the Node Reference field.
 */

/**
 * Implementation of hook_theme().
 */
function nodereference_character_theme() {
  return array(
    'nodereference_character' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implementation of hook_form_alter().
 */
/*
function nodereference_character_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'content_field_edit_form' && isset($form['#field']) && $form['#field']['widget']['type'] == 'nodereference_character') {
    // Hide settings that don't apply to this widget.
    $form['field']['multiple']['#type'] = 'value';
    $form['widget']['description']['#type'] = 'value';
  }
}
*/

/**
 * Implementation of hook_widget_info().
 */
function nodereference_character_widget_info() {
  return array(
    'nodereference_character' => array(
      'label' => t('WeBB: Character select list (3)'),
      'field types' => array('nodereference'),
      'multiple values' => CONTENT_HANDLE_MODULE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of FAPI hook_elements().
 *
 * Any FAPI callbacks needed for individual widgets can be declared here,
 * and the element will be passed to those callbacks for processing.
 *
 * Drupal will automatically theme the element using a theme with
 * the same name as the hook_elements key.
 *
 * Autocomplete_path is not used by text_widget but other widgets can use it
 * (see nodereference and userreference).
 */
function nodereference_character_elements() {
  return array(
    'nodereference_character' => array(
      '#input' => TRUE,
      '#columns' => array('nid'),
      '#delta' => 0,
      '#process' => array('nodereference_character_process'),
    ),
  );
}

/**
 * Implementation of hook_widget_settings().
 */
/*
function nodereference_character_widget_settings($op, $widget) {
  switch ($op) {
  	case 'form':
      break;
    case 'save':
      return array('node_link', 'fallback');
  }
}
*/

/**
 * Element validation function to ensure invalid options are not selected.
 */
/*
function nodereference_character_fallback_validate($element, &$form_state) {
  if ($form_state['values']['required'] && $form_state['values']['fallback'] == 'leave_blank') {
    form_error($element, t('The fallback behavior cannot be left blank if this field is also required.'));
  }
}
*/

/**
 * Element validation function that makes title required when creating a link.
 */
/*
function nodereference_character_node_link_validate($element, &$form_state) {
  if ($form_state['values']['node_link']['enabled'] && empty($form_state['values']['node_link']['title'])) {
    form_error($element['title'], t('A link title must be specified if creating links on referenceable content.'));
  }
}
*/

/**
 * Implementation of hook_widget().
 */
function nodereference_character_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  switch ($field['widget']['type']) {
    case 'nodereference_character':
      $element = array(
        '#type' => 'nodereference_character',
        '#default_value' => $items,
      );
      break;
  }
  return $element;

/*
  $element = array('#tree' => TRUE);

  $default_value = 0;
  if (isset($form['#node']->$field['field_name'])) {
    $field_name = $field['field_name'];
    $field_fragment = $form['#node']->$field_name;
    $default_value = $field_fragment[$delta]['nid'];
  }

  $element = array(
    '#title' => $field['widget']['label'],
    '#type' => 'nodereference_character',
    '#field_name' => $field['field_name'],
    '#default_value' => $default_value,
  );

  return $element;
*/
}

/**
 * Process an individual element.
 *
 * Build the form element. When creating a form using FAPI #process,
 * note that $element['#value'] is already set.
 *
 * The $fields array is in $form['#field_info'][$element['#field_name']].
 */
function nodereference_character_process($element, $edit, $form_state, $form) {
  // The nodereference_select widget doesn't need to create its own
  // element, it can wrap around the optionwidgets_select element.
  // This will create a new, nested instance of the field.
  // Add a validation step where the value can be unwrapped.
  $field_key  = $element['#columns'][0];
  $element[$field_key] = array(
    '#type' => 'optionwidgets_select',
    '#default_value' => isset($element['#value']) ? $element['#value'] : '',
    // The following values were set by the content module and need
    // to be passed down to the nested element.
    '#title' => $element['#title'],
    '#required' => $element['#required'],
    '#description' => $element['#description'],
    '#field_name' => $element['#field_name'],
    '#type_name' => $element['#type_name'],
    '#delta' => $element['#delta'],
    '#columns' => $element['#columns'],
  );
  if (empty($element[$field_key]['#element_validate'])) {
    $element[$field_key]['#element_validate'] = array();
  }
  array_unshift($element[$field_key]['#element_validate'], 'nodereference_optionwidgets_validate');
  return $element;  

/*
  // If this is a new node, we want to show all characters on this OG owned
  // by the current user.  If we're editing a node, we want to show all
  // characters on this OG owned by the node's owner.  Yes, it's wacky.
  if (isset($_GET['gids'])) {
    $params = $_GET['gids'];
    global $user;
    $uid = $user->uid;
    $new_node = TRUE;
  }
  else {
    $node = $form['#node'];
    $params = $node->og_groups;
    $uid = $node->uid;
    $new_node = FALSE;
  }

  if (count($params)) { // This should only ever be false on the content type edit form, because CCK is weird and calls form_alter when it doesn't have to (at least in D5).
    $dbinfo = content_database_info(content_fields('field_display_name'));

  	$placeholders = db_placeholders($params, 'int');
    $params[] = $uid;
    $characters = db_fetch_assoc("SELECT n.nid, {$dbinfo['columns']['value']['column']}
      FROM {node} n
        INNER JOIN {$dbinfo['table']} ctc ON n.vid=ctc.vid
        INNER JOIN {og_ancestry} oa ON ctc.nid=oa.nid
      WHERE oa.group_nid IN (" . $placeholders . ")
        AND n.uid=%d
      ORDER BY title", $params);
  }
  else {
    $characters = array();
  }

  $options = array(0 => t('<none>')) + $characters;

  // Default to the most recently used character on this board by this person,
  // if it's a new node.
  if ($new_node && count($characters)) {
    $dbinfo = content_database_info(content_fields('field_character'));

    $placeholders = db_placeholders($characters, 'int');
    $default_value = db_result(db_query_range("SELECT ctn.field_character_nid
      FROM {node} n
        INNER JOIN {content_type_note} ctn on n.nid=ctn.nid AND n.vid=ctn.vid
      WHERE ctn.field_character_nid IN (" . $placeholders . ")
      ORDER BY n.created DESC", array_keys($characters), 0, 1));
  }
*/

  /*
  if (isset($_GET['gids'])) {
    $params = $_GET['gids'];
    global $user;
    $uid = $user->uid;
    $new_node = TRUE;
  }
  else {
    $node = $form['#node'];
    $params = $node->og_groups;
    $uid = $node->uid;
    $new_node = FALSE;
  }

  if (count($params)) { // This should only ever be false on the content type edit form, because CCK is weird and calls form_alter when it doesn't have to.
    $placeholders = implode(',', array_fill(0, count($params), '%d'));
    $params[] = $uid;
    $characters = db_fetch_assoc("SELECT n.nid, field_display_name_value
      FROM {node} n
        INNER JOIN {content_type_character} ctc ON n.vid=ctc.vid
        INNER JOIN {og_ancestry} oa ON ctc.nid=oa.nid
      WHERE oa.group_nid IN (" . $placeholders . ")
        AND n.uid=%d
      ORDER BY title", $params);
  }
  else {
    $characters = array();
  }
  */

/*
  $element[$field_key] = array(
    '#type' => 'select',
    // The following values were set by the content module and need
    // to be passed down to the nested element.
    '#title' => $element['#title'],
    '#required' => $element['#required'],
    '#description' => $element['#description'],
    '#field_name' => $element['#field_name'],
    '#type_name' => $element['#type_name'],
    '#delta' => $element['#delta'],
    '#columns' => $element['#columns'],
    '#options' => $options,
    '#default_value' => $default_value,
  );

  return $element;
*/
  /*
	$field_key  = $element['#columns'][0];
  $field = $form['#field_info'][$element['#field_name']];

  if (isset($element['#value']) && is_numeric($element['#value'])) {
    $element['#display_title'] = _nodereference_titles($element['#value']);
  }
  else {
    $element['#display_title'] = t('Referenced content not found.');
  }

  $element['nid'] = array(
    '#type' => 'value',
    '#value' => isset($element['#value']) ? $element['#value'] : $element['#value'],
    '#parents' => $element['#parents'],
  );

  return $element;
  */

  /*
  $field_key  = $element['#columns'][0];
  $element[$field_key] = array(
    '#type' => 'optionwidgets_select',
    '#default_value' => isset($element['#value']) ? $element['#value'] : '',
    // The following values were set by the content module and need
    // to be passed down to the nested element.
    '#title' => $element['#title'],
    '#required' => $element['#required'],
    '#description' => $element['#description'],
    '#field_name' => $element['#field_name'],
    '#type_name' => $element['#type_name'],
    '#delta' => $element['#delta'],
    '#columns' => $element['#columns'],
  );
  if (empty($element[$field_key]['#element_validate'])) {
    $element[$field_key]['#element_validate'] = array();
  }
  array_unshift($element[$field_key]['#element_validate'], 'nodereference_optionwidgets_validate');
  return $element;


   */
}



/**
 * FAPI theme for an individual elements.
 *
 * The textfield or select is already rendered by the
 * textfield or select themes and the html output
 * lives in $element['#children']. Override this theme to
 * make custom changes to the output.
 *
 * $element['#field_name'] contains the field name
 * $element['#delta]  is the position of this element in the group
 */
function theme_nodereference_character($element) {
  return $element['#children'];
}
