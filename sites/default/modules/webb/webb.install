<?php

function webb_install() {
  // Create tables.
  drupal_install_schema('webb');
}

/**
 * Add the denormalization table for the note listing.
 */
function webb_update_5001() {

  $ret[] = update_sql("CREATE TABLE {webb_note_lookup} (
      nid int(10) NOT NULL,
      group_nid int(10) NOT NULL,
      created int(11) NOT NULL,
      PRIMARY KEY (nid, group_nid),
      KEY (group_nid, created, nid)
    ) COMMENT='Denormalization lookup table'
    /*!40100 DEFAULT CHARACTER SET utf8 */");

  return $ret;
}

/**
 * Implementation of hook_schema().
 */
function webb_schema() {

  $schema['webb_board_positions'] = array(
    'fields' => array(
         'nid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0, 'disp-width' => '10'),
         'tid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0, 'disp-width' => '10')),
    'primary key' => array('nid', 'tid'),
  );

  $schema['webb_board_ranks'] = array(
    'fields' => array(
         'nid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0, 'disp-width' => '10'),
         'tid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0, 'disp-width' => '10')),
    'primary key' => array('nid', 'tid'),
  );

  $schema['webb_note_lookup'] = array(
    'fields' => array(
         'nid' => array('type' => 'int', 'not null' => TRUE, 'disp-width' => '10'),
         'group_nid' => array('type' => 'int', 'not null' => TRUE, 'disp-width' => '10'),
         'created' => array('type' => 'int', 'not null' => TRUE, 'disp-width' => '11')),
    'primary key' => array('nid', 'group_nid'),
    'indexes' => array(
         'group_nid' => array('group_nid', 'created', 'nid')),
  );

  return $schema;
}

/**
 * Populate the denormalization table.
 */
function webb_update_5002() {
    // See if we are being called for the first time
  if (!isset($_SESSION['webb_update_5002_nid'])) {
    // These variables keep track of our progress
    $_SESSION['webb_update_5002_nid'] = 0;
    $_SESSION['webb_update_5002_max'] = db_result(db_query("SELECT MAX(nid) FROM {node} WHERE type='note'"));
  }

  // Fetch the next N note nodes and populate the lookup table.
  $limit = 100;
  $result = db_query_range("SELECT n.nid, created, group_nid
    FROM {node} n
      INNER JOIN {og_ancestry} oa ON n.nid=oa.nid
    WHERE n.type = 'note'
      AND n.status = 1
      AND n.nid > %d
    ORDER BY n.nid ASC", $_SESSION['webb_update_5002_nid'], 0, 100);
  while ($record = db_fetch_object($result)) {
    db_query("INSERT INTO {webb_note_lookup} (nid, group_nid, created) VALUES (%d, %d, %d)", array(
      $record->nid, $record->group_nid, $record->created,
    ));
    $_SESSION['webb_update_5002_nid'] = $record->nid;
  }

  // See if we are done
  if ($_SESSION['webb_update_5002_nid'] < $_SESSION['webb_update_5002_max']) {
    // Not done yet. Return the progress.
    $return = array('#finished' => $_SESSION['webb_update_5002_nid'] / $_SESSION['webb_update_5002_max']);
    return $return;
  }
  else {
    // Done. Clean up and indicate we're finished.
    unset($_SESSION['webb_update_5002_nid']);
    unset($_SESSION['webb_update_5002_max']);
    return array('#finished' => 1);
  }
}

/**
 * Auto-set some settings needed by OG 7.x.
 */
function webb_update_5003() {
  $ret = array();

  variable_set('og_content_type_usage_character', 'group_post_standard_nomail');
  variable_set('og_content_type_usage_logentry', 'group_post_standard_nomail');
  variable_set('og_content_type_usage_note', 'group_post_standard_nomail');
  variable_set('og_content_type_usage_page', 'group_post_standard_nomail');

  return $ret;
}

/**
 * Force all users to not be subscribed to OG email notifications by default.
 */
function webb_update_5004() {
  $ret = array();

  $ret[] = update_sql("UPDATE {og_uid_global} SET og_email=0");

  return $ret;
}

/**
 * TEMP update for clearing older nodes for testing.
 *
 * DO NOT RUN THIS DURING A REAL UPGRADE!
 */
/*
function webb_update_5007() {

  if (!isset($_SESSION['webb_update_5005_time'])) {
    // These variables keep track of our progress

    $_SESSION['webb_update_5005_time'] = strtotime('-2 weeks');

    $_SESSION['webb_update_5005_num_nodes'] = db_result(db_query("SELECT COUNT(*) FROM {node} n WHERE n.type = 'note' AND created < %d", $_SESSION['webb_update_5005_time']));
  }

  $limit = 100;
  $result = db_query_range("SELECT n.nid FROM {node} n WHERE n.type = 'note' AND created < %d ORDER BY nid", $_SESSION['webb_update_5005_time'], 0, $limit);
  while ($record = db_fetch_object($result)) {
    node_delete($record->nid);
  }

  $count = db_result(db_query("SELECT COUNT(*) FROM {node} n WHERE n.type = 'note' AND created < %d", $_SESSION['webb_update_5005_time']));

  if ($count) {
    // Not done yet. Return the progress.
    $return = array('#finished' => 1 - ($count / $_SESSION['webb_update_5005_num_nodes']));
    return $return;
  }
  else {
    // Done. Clean up and indicate we're finished.
    unset($_SESSION['webb_update_5005_time']);
    unset($_SESSION['webb_update_5005_num_nodes']);
    return array('#finished' => 1);
  }
}
*/

/**
 * Enable modules that we now are using.
 */
function webb_update_6001() {
  module_enable(array(
    // New modules.
    'auto_nodetitle', 'helpers_database', 'advanced_help',

    // Legal seemed to turn itself off somewhere, so just to be safe we'll force
    // it to enable again.
    'legal',

    // We just need these enabled for the upgrade process to go smoothly.
    'fieldgroup', 'userreference',
  ));

  return array();
}

/**
 * Set the auto_nodetitle configurations we want.
 */
function webb_update_6002() {
  // For Note nodes.
  variable_set('ant_note', 1);
  variable_set('ant_php_note', 1);
  variable_set('ant_pattern_note', "<?php
return t('@topic on @board', array(
  '@topic' => \$node->field_topic[0]['value'],
  '@board' => og_get_group_context()->title,
));
?>");

  // For CO Log nodes.
  variable_set('ant_logentry', 1);
  variable_set('ant_php_logentry', 1);
  variable_set('ant_pattern_logentry', "<?php return format_date(\$node->created, 'custom', 'd M Y') ?>");

  return array();
}

/**
 * Create the new rank system..
 *
 * 1) Create the Rank node type.
 * 2) Create the Rank set vocabulary.
 * 3) Create our one existing Rank st (Starfleet).
 * 4) Create a Rank node for each existing rank.
 * 5) Build a map of rank terms to rank nodes.
 * 6) Add a new rank noderef field to character nodes.
 * 7) Associate all characters with the new rank nodes.
 * 8) Remove the old rank vocabulary.
 *
 */
function webb_update_6003() {
  $ret = array();

  // Create the node type itself.
  $info = (object)array(
    'type' => 'rank',
    'name' => 'Rank',
    'description' => 'A rank held by a character',
    'module' => 'node',
    'has_title' => TRUE,
    'title_label' => 'Rank name',
    'has_body' => FALSE,
    'body_label' => '',
    'custom' => TRUE,
    'modified' => TRUE,
    'locked' => FALSE,
  );
  node_type_save($info);
  variable_set('node_options_rank', array('status'));
  variable_set('comment_rank', COMMENT_NODE_DISABLED);

  content_clear_type_cache();
  module_load_include('inc', 'content', 'includes/content.crud');

  // The sortorder field already exists, so we'll just reuse it.
  content_field_instance_create(array(
    'field_name' => 'field_sortorder',
    'type_name' => 'rank',
  ));

  // Create the rankset vocabulary.
  $edit = array(
    'name' => 'Rank set',
    'description' => 'A rank set is a collection of ranks that should be available together.',
    'help' => 'Pick the related rank sets',
    'tags' => 0,
    'multiple' => '1',
    'relations' => '1',
    'nodes' => array('rank' => 'rank', 'board' => 'board'),
  );
  taxonomy_save_vocabulary($edit);
  $vid = $edit['vid'];

  // Create our one rank set for now (Starfleet).
  $edit = array(
    'name' => 'Starfleet',
    'description' => '',
    'parent' => array(),
    'relations' => array(),
    'weight' => 0,
    'vid' => $vid,
  );
  taxonomy_save_term($edit);
  $tid = $edit['tid'];

  // Associate all Boards to the Starfleet rank set.
  $result = db_query("SELECT nid, vid FROM {node} WHERE type='board'");
  while ($record = db_fetch_object($result)) {
    taxonomy_node_save($record, array($tid));
  }

  // For each existing rank term, create a corresponding Rank node.  For now
  // we can safely assume that all ranks are Starfleet ranks.  Then delete the
  // old vocabulary so we don't have stale data lying around.
  $conversion_map = array();
  $old_rank_vid = 1;  // We just sorta know this. :-)
  $result = db_query("SELECT tid, name, description, weight FROM {term_data} WHERE vid = %d", $old_rank_vid);
    while ($record = db_fetch_object($result)) {
    $node = new stdClass();
    $node->status = 1;
    $node->uid = 1;
    $node->type = 'rank';
    $node->created = time();
    $node->updated = $node->created;
    $node->title = $record->name;
    $node->body = '';
    $node->field_sortorder[0]['value'] = $record->weight;
    $node->taxonomy = array(
      $tid => (object)array(
        'tid' => $tid,
        'vid' => $vid,
      ),
    );
    node_save($node);
    $conversion_map[$record->tid] = $node->nid;

    drupal_set_message(t('Creating rank %rank', array(
      '%rank' => $record->name,
    )));
  }

  // Create the rank reference field on Character nodes.
  content_clear_type_cache();
  module_load_include('inc', 'content', 'includes/content.crud');
  $field = content_field_instance_create(array(
    'label' => 'Rank',
    'field_name' => 'field_rankref',
    'type' => 'nodereference',
    'widget_type' => 'nodereference_select',
    'type_name' => 'character',
    'required' => 0,
    'weight' => -3,
  ));
  $field['referenceable_types'] = array('rank' => 'rank');
  $field['advanced_view'] = 'og_supported_ranks'; // Replace with view name later.
  content_field_instance_update($field);
  content_clear_type_cache();

  // Migrate the existing rank info from cck_taxonomy to the noderef field.  Yay, hacky!
  foreach ($conversion_map as $tid => $nid) {
    db_query('UPDATE {content_type_character} SET field_rankref_nid = %d WHERE field_rank_tid = %d', $nid, $tid);
  }

  // Remove the now defunct cck_taxonomy field for ranks.  Because the managing
  // module is not used anymore, we can't go through CCK for this.  Instead we
  // futz with CCK's tables manually.  Yeah, we're totally being rebels about it.
  db_drop_field($ret, 'content_type_character', 'field_rank_tid');
  db_query("DELETE FROM {content_node_field_instance} WHERE field_name = '%s'", 'field_rank');
  db_query("DELETE FROM {content_node_field} WHERE field_name = '%s'", 'field_rank');
  content_clear_type_cache();

  // Now, finally remove the old vocabularly as we no longer need it.
  taxonomy_del_vocabulary($old_rank_vid);

  return $ret;
}

