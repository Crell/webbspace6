<?php

/* ------------------- Miscellaneous -------------------*/

// Because we store menu permissions here, it has to be included
// before hook_init() runs.  This is a design flaw in Drupal, IMO.
module_load_include('inc', 'webb', 'webb.utility');

/**
 * Implementation of hook_init().
 *
 * These files are separated out for maintenance only.  They're still
 * always needed.
 */
function webb_init() {
  module_load_include('inc', 'webb', 'webb_nodes');
  module_load_include('inc', 'webb', 'webb.computed_field');
  //module_load_include('inc', webb, 'dbhelpers');
}

/**
 * Implementation of hook_views_api().
 */
function webb_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'webb'),
  );
}

/**
 * Implementation of hook_perm().
 */
function webb_perm() {
  $perms = array('read notes', 'post notes');

  foreach (array_keys(webb_node_info()) as $type) {
    $perms[] = 'create '. $type .' content';
    $perms[] = 'edit any '. $type .' content';
    $perms[] = 'edit own '. $type .' content';
    $perms[] = 'delete any '. $type .' content';
    $perms[] = 'delete own '. $type .' content';
  }

  return $perms;
}

/**
 * Implementation of hook_node_info().
 */
function webb_node_info() {
  return array(
    'character' => array(
      'name' => t('Character'),
      'module' => 'webb_character',
      'description' => t("A character on an RPG board."),
      'title_label' => t('Character name'),
      'body_label' => t('Bio'),
    ),
    'board' => array(
      'name' => t('Board'),
      'module' => 'webb_board',
      'description' => t('A board is where a RPG events take place.'),
      'title_label' => t('Name'),
      'body_label' => t('MOTD'),
    ),
  );
}

/**
 * Implementation of hook_nodeapi().
 */
function webb_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {

  // Break out node operations to a handler function for each node type.
  if (!empty($node->type)) {
    $function = '_webb_nodeapi_'. $node->type;
    if (function_exists($function)) {
      $function($node, $op, $a3, $a4);
    }
  }
}

/**
 * Helper function for hook_nodeapi().
 */
function _webb_nodeapi_note(&$node, $op, $a3 = NULL, $a4 = NULL) {

  switch ($op) {
    case 'insert':
    case 'update':
      // Save the denormalization data so that we can run a query in less than an hour.
      db_query("DELETE FROM {webb_note_lookup} WHERE nid=%d", $node->nid);
      if ($node->status == 1) {
        foreach ($node->og_groups as $group_nid) {
          db_query("INSERT INTO {webb_note_lookup} (nid, group_nid, created) VALUES (%d, %d, %d)", array(
            $node->nid, $group_nid, $node->created,
          ));
        }
      }
      break;
    case 'view':
      if ($a4) {  // in $op=view, $a4 is the $page boolean.
      }
      break;
  }
}

/**
 * Helper function for hook_nodeapi().
 */
function _webb_nodeapi_character(&$node, $op, $a3 = NULL, $a4 = NULL) {
  static $node_owner;

  switch ($op) {
    case 'submit':
      // In order to save the node owner even if the user doesn't have "administer nodes" permission,
      // we need to grab the submitted value here, cache it, and then save it in the insert/update op
      // in a moment.  We can't save it here or in a form_alter submit callback because we need the
      // nid and vid, and those don't exist until the insert/update ops and aren't passed to the
      // form_alter if we're dealing with a new node.  Ugh!
      $node_owner = $node->name;
      break;
    case 'insert':
    case 'update':
      if (_webb_is_og_admin($node->og_groups)) {
        // Populate the "authored by" field.
        if ($account = user_load(array('name' => $node_owner))) {
          db_query("UPDATE {node} SET uid=%d WHERE nid=%d AND vid=%d", $account->uid, $node->nid, $node->vid);
        }
        else {
          drupal_set_message('Sorry, that username does not exist in the system.', 'error');
        }
      }
      break;
  }
}

/* ------------------- Menu -------------------*/

function og_webb_menu_alter(&$items) {
  // We're providing our own way to create new note nodes,
  // so get rid of the default one.
  unset($items['node/add/note']);
}


/**
 * Implementation of hook_menu().
 */
function webb_menu() {
  $items = array();
  global $language;
  global $user;

  // Admin form to configure what our postable node types are.
  $items['admin/og/webb-post'] = array(
    'title' => 'WeBB posting',
    'description' => 'Configure the WeBBspace posting system.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webb_settings'),
    'access arguments' => array('administer WeBB posting'),
    'file' => 'webb.admin.inc',
  );

  // We're moving the node add form to a tab of the board.
  $type = node_get_types('type', 'note', TRUE);
  $items["node/%node/post"] = array(
    'title' => 'New note',
    'page callback' => 'node_add',
    'page arguments' => array($type->type),
    'access callback' => 'webb_menu_access_allow_posting',
    'access arguments' => array(1, $type->type),
    'description' => $type->description,
    'file' => 'node.pages.inc',
    'file path' => drupal_get_path('module', 'node'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
  );

  // Set up the administrative area of each Board, underneath the edit tab.
  $items['node/%webb_postable_node/edit/basic'] = array(
    'title' => 'Base settings',
    'page callback' => 'node_page_edit',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'weight' => -1,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  foreach (array('logentry', 'character') as $type_name) {
    $type = node_get_types('type', $type_name, TRUE);
    $type->url_str = str_replace('_', '-', $type->type);
    $items['node/%webb_postable_node/edit/add-'. $type->url_str] = array(
      'title' => 'Post new '. $type->name,
      'page callback' => 'node_add',
      'page arguments' => array($type_name),
      'access callback' => 'webb_menu_access_allow_posting',
      'access arguments' => array(1, $type->type),
      'description' => $type->description,
      'file' => 'node.pages.inc',
      'file path' => drupal_get_path('module', 'node'),
      'type' => MENU_LOCAL_TASK,
    );
  }

  /*
  $items["node/{$node->nid}/admin/add_user"] = array(
    'title' => 'Add subscribers',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('og_add_users', $node->nid),
    'type' => MENU_SUGGESTED_ITEM,
    'weight' => 5,
    'access arguments' => _webb_is_og_admin($node->nid),
    'description' => 'Add a subscriber to this board.',
  );
  */

/* TODO
   Non menu code that was placed in hook_menu under the '!$may_cache' block
   so that it could be run during initialization, should now be moved to hook_init.
   Previously we called hook_init twice, once early in the bootstrap process, second
   just after the bootstrap has finished. The first instance is now called boot
   instead of init.

   In Drupal 6, there are now two hooks that can be used by modules to execute code
   at the beginning of a page request. hook_boot() replaces hook_boot() in Drupal 5
   and runs on each page request, even for cached pages. hook_boot() now only runs
   for non-cached pages and thus can be used for code that was previously placed in
   hook_menu() with $may_cache = FALSE:

   Dynamic menu items under a '!$may_cache' block can often be simplified
   to remove references to arg(n) and use of '%<function-name>' to check
   conditions. See http://drupal.org/node/103114.

   The title and description arguments should not have strings wrapped in t(),
   because translation of these happen in a later stage in the menu system.
*/
  if ($may_cache) {

  }
  else {
    // The following apply only to certain node types
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $node = node_load(arg(1));

      // Only OG node types get these extra menu items
      if (og_is_group_type($node->type)) {

        // Allow direct access to OG functionality without using the moronic sidebar block.
        $items["node/{$node->nid}/admin/subscribers"] = array(
          'page callback' => 'og_menu_check',
          'title' => 'Subscribers',
          'page arguments' => array('og_list_users_page', $node->nid),
          'type' => MENU_SUGGESTED_ITEM,
          'access arguments' => _webb_is_og_admin($node->nid),
          'description' => 'View subscribers on this board and edit which of them are managers.'
        );
        $items["node/{$node->nid}/admin/add_user"] = array(
          'title' => 'Add subscribers',
          'page callback' => 'drupal_get_form',
          'page arguments' => array('og_add_users', $node->nid),
          'type' => MENU_SUGGESTED_ITEM,
          'weight' => 5,
          'access arguments' => _webb_is_og_admin($node->nid),
          'description' => 'Add a subscriber to this board.',
        );
      }
    }


  }

  return $items;
}

/**
 * Menu loader callback. Load a postable node if the given nid is postable.
 */
function webb_postable_node_load($nid) {
  if (!is_numeric($nid)) {
    return FALSE;
  }
  $node = node_load($nid);
  if (! webb_is_post_type($node->type)) {
    return FALSE;
  }
  return $node;
}

/**
 * Menu access callback for the Notes tab on postable OGs.
 *
 * @param $node
 */
function webb_menu_access_supports_posting($node) {
  return webb_is_post_type($node->type) && user_access('read notes');
}

/**
 * Menu access callback for the custom node add page for notes.
 */
function webb_menu_access_allow_posting($board, $type) {
  return webb_is_post_type($board->type) && node_access('create', $type);
}

/* ------------------- Links -------------------*/

/**
 * Implementation of hook_project_page_link_alter(&$links, $node).
 *
 * This is for project.module, which we're keeping disabled for now.
 */
/*
function webb_project_page_link_alter($project, &$all_links) {

  // Remove a couple of links that don't make any sense.
  unset($all_links['development']['links']['pending_patches']);

}
*/

/**
 * Implementation of hook_link().
 *
 */
function webb_link($type, $node=NULL, $teaser=FALSE) {
  $links = array();

  if ($type == 'node' && $node->type == 'note') {
    $links = array_merge($links, _webb_link_note($node, $teaser));
  }

  if ($type == 'node' && webb_is_post_type($node->type)) {
    $links = array_merge($links, _webb_link_post_type($node, $teaser));
  }

  return $links;
}


/**
 * Helper function for hook_link() on "note" nodes
 */
function _webb_link_note($node, $teaser) {
  global $user;

  $links = array();

  $group_nid = current($node->og_groups);
  if ($group_nid) {
    $group = node_load($group_nid);

    // Add a HEAD LINK to the board, and to the note list
    drupal_add_link(array('rel' => 'start', 'href' => url('node/'. $group_nid)));
    drupal_add_link(array('rel' => 'index', 'href' => url('node/'. $group_nid .'/notes')));

    // Create a temporary table to generate the links below
    db_query_temporary("SELECT nid, created 
      FROM node 
      WHERE created >= %d 
        AND created <= %d 
        AND status = 1 
        AND type = '%s'", 
      array($node->created - 7776000, $node->created + 7776000, $node->type), 
      'recent_posts'
    );

    // Add a link to the previous note chronologically on this board
    $prev_by_time = db_result(
      db_query_range("SELECT n.nid
        FROM {recent_posts} n INNER JOIN {og_ancestry} oa ON n.nid=oa.nid
        WHERE oa.group_nid = %d
          AND n.created < %d
        ORDER By created DESC",
        array($group_nid, $node->created), 0, 1)
    );
    if ($prev_by_time) {
      $links['prev_by_time'] = array(
        'title' => t("Previous note"),
        'href' => "node/{$prev_by_time}",
        'attributes' => array(
          'title' => t("View the previous note on this board"),
         ),
      );
      drupal_add_link(array('rel' => 'prev', 'href' => url('node/'. $prev_nid)));
    }
/*
    // Add a link back to the Board
    $links['view_board'] = array(
      'title' => t("Back to !boardname", array('!boardname' => $group->title)),
      'href' => "node/{$group_nid}",
      'attributes' => array(
        'title' => t("Back to Board"),
       ),
    );
*/
    // Add a link to the parent note, if any
    if ($node->field_parent_note[0]['nid']) {
      $links['parent_note'] = array(
        'title' => t("Parent"),
        'href' => "node/{$node->field_parent_note[0]['nid']}",
        'attributes' => array(
          'title' => t("Go to parent note"),
         ),
      );
      drupal_add_link(array('rel' => 'up', 'href' => url('node/'. $node->field_parent_note[0]['nid'])));
    }

    // Add a "reply" link
    if (user_access('post notes')) {
      $links['reply'] = array(
        'title' => t("Reply"),
        'href' => "node/{$group->nid}/post/". $node->nid,
        'query' => 'parent_nid='. $node->nid,
        'attributes' => array(
          'title' => t("Post a reply to this note"),
         ),
      );
    }
    

    // Add a link to the next note chronologically on this board.
    $next_by_time = db_result(
      db_query_range("SELECT n.nid
        FROM {recent_posts} n INNER JOIN {og_ancestry} oa ON n.nid=oa.nid
        WHERE oa.group_nid=%d
          AND n.created > %d
        ORDER By created",
        array($group_nid, $node->created), 0, 1)
    );
    if ($next_by_time) {
      $links['next_by_time'] = array(
        'title' => t("Next chronologically"),
        'href' => "node/{$next_by_time}",
        'attributes' => array(
          'title' => t("View the next note on this board"),
         ),
      );
      drupal_add_link(array('rel' => 'next', 'href' => url('node/'. $next_nid)));
    }

    // Add a link to the next note in the same topic.
    $dbinfo = content_database_info(content_fields('field_topic'));
    $next_in_topic = db_result(
        db_query_range("SELECT n.nid
          FROM {recent_posts} n
            INNER JOIN {og_ancestry} oa ON n.nid=oa.nid
            INNER JOIN {{$dbinfo['table']}} f ON f.nid=n.nid
          WHERE oa.group_nid=%d
            AND n.created > %d
            AND f.{$dbinfo['columns']['value']['column']}='%s'
          ORDER By created",
          array($group_nid, $node->created, $node->field_topic[0]['value']), 0, 1)
      );
    if ($next_in_topic) {
      $topic_label = db_result(db_query("SELECT label FROM {webbtopic_label} WHERE nid=%d", array($group_nid)));
      $links['next_in_topic'] = array(
        'title' => t("Next in @topic", array('@topic' => $topic_label)),
        'href' => "node/{$next_in_topic}",
        'attributes' => array(
          'title' => t("View the next note on this board in the same @topic", array('@topic' => $topic_label)),
        ),
      );
    }

    // Add a link to the next unread note chronologically on this board.
    if ($user->uid) {
      $next_unread = db_result(
        db_query_range("SELECT n.nid
          FROM {recent_posts} n
            INNER JOIN {og_ancestry} oa ON n.nid=oa.nid
            LEFT OUTER JOIN {history} h ON h.uid=%d AND h.nid=n.nid
          WHERE oa.group_nid=%d
            AND n.created > %d
            AND h.nid IS NULL
          ORDER By created",
          array($user->uid, $group_nid, $node->created), 0, 1)
      );
      if ($next_unread) {
        $links['next_unread'] = array(
          'title' => t("Next new note"),
          'href' => "node/{$next_unread}",
          'attributes' => array(
            'title' => t("View the next note on this board after this one that you have not yet read"),
          ),
        );
      }
    }
   
   // Drop temporary table
   db_query_temporary("DROP TABLE {recent_posts}");

  }

  return $links;
}

/**
 * Helper function for hook_link() on "board" nodes.
 */
function _webb_link_post_type($node, $teaser) {
  $links = array();

  // Add a HEAD LINK to the note list
  drupal_add_link(array('rel' => 'index', 'href' => url('node/'. $node->nid . '/notes')));

  $links['read_notes'] = array(
    'title' => t("Read Notes"),
    'href' => "node/{$node->nid}/notes",
    'attributes' => array(
      'title' => t("See recently-posted notes on this board"),
     ),
  );

  // Anonymous users don't get to see subscriptions at all.
  if ($GLOBALS['user']->uid) {
    if (_webb_og_is_subscriber($node->nid)) {
      $links['manage_subscription'] = array(
        'title' => t("Manage subscription"),
        'href' => 'og/manage/'. $node->nid,
        'query' => drupal_get_destination(),
        'attributes' => array(
          'title' => t("Unsubscribe from this group or change your email subscription"),
         ),
      );
    }
    else {
      $links['add_subscription'] = array(
        'title' => t("Subscribe"),
        'href' => 'og/subscribe/'. $node->nid,
        'query' => drupal_get_destination(),
        'attributes' => array(
          'title' => t("Subscribe to this group"),
         ),
      );
    }
  }

  if (_webb_is_og_admin($node->nid)) {
    $links['post_log_entry'] = array(
      'title' => t("Post Log Entry"),
      'href' => "node/{$node->nid}/admin/logentry",
      'query' => 'gids[]=' . $node->nid,
      'attributes' => array(
        'title' => t("Post a Captain's Log entry"),
      ),
    );
  }

  return $links;
}


/* ------------------- Form Alter -------------------*/

/**
 * Implementation of hook_form_alter
 */
function webb_form_alter(&$form, &$form_state, $form_id) {

  if ($form['#id'] == 'node-form' && webb_is_post_type($form['type']['#value'])) {
    _webb_form_alter_postable_node_form($form, $form_state);
  }
  elseif ($form_id == 'character_node_form') {
    // This has to be done here, rather than in a form-specific hook, because
    // it has to run after cck does since we're modifying CCK-added form structures.

    // Hide some fields from non-admins, because we don't want people editing
    // their own rank.
    // Note that we cannot do this for checkboxes, only select boxes, due to
    // a ridiculously obscure bug in optionwidget that I can't even figure out.
    $access = _webb_is_og_admin(og_get_group_context()->nid);
    $form['field_rankref']['#access'] = $access;
    $form['field_positionref']['#access'] = $access;
    $form['field_custom_position']['#access'] = $access;
    $form['field_rostered']['#access'] = $access;
  }
  elseif ($form_id == 'note_node_form') {
    // This has to be done here, rather than in a form-specific hook, because
    // it has to run after cck does since we're modifying CCK-added form structures.

    // In order to set the default value of the character select box, we need to
    // hook into the form building process after the CCK field gets built out.
    // That requires we add in our own process function to run after the
    // built-in one.  And of course we have to redeclare the built in one so that
    // it still runs.  How does this make any sense?
    $form['field_character']['#process'][] ='nodereference_select_process';
    $form['field_character']['#process'][] ='webb_field_character_process';
  }
  elseif ('views_filters' == $form_id && $form['view']['#value']->name == 'og_notes') {
    _webb_form_alter_og_notes_filter_form($form_id, $form);
  }
}

/**
 * Process callback for character fields.
 *
 * Because CCK nodereference select boxes are a two-step build process, due to
 * the use of optionwidgets, we need to parallel that two-step process ourselves.
 * Can I start crying now?
 */
function webb_field_character_process($element, $edit, $form_state, $form) {

  $element['nid']['#process'][] = 'optionwidgets_select_process';
  $element['nid']['#process'][] = 'webb_field_character_process_phase2';

  return $element;
}

/**
 * Process callback for character fields part 2.
 */
function webb_field_character_process_phase2($element, $edit, $form_state, $form) {
  $characters = array_filter(array_keys($element['nid']['#options']));

  // If there is no default character set, set it to the character in the
  // select box that was most recently used.
  if ($characters && !$element['nid']['#default_value']['nid']) {
    $dbinfo = content_database_info(content_fields('field_character'));

    $default_character = db_result(db_query_range("SELECT ctn.{$dbinfo['columns']['nid']['column']}
        FROM {node} n
          INNER JOIN {{$dbinfo['table']}} ctn on n.nid=ctn.nid AND n.vid=ctn.vid
        WHERE ctn.{$dbinfo['columns']['nid']['column']} IN (" . db_placeholders($characters) . ")
        ORDER BY n.created DESC", $characters, 0, 1));

    $element['nid']['#default_value']['nid'] = $default_character;
  }

  return $element;
}


function webb_form_advpoll_binary_node_form_alter(&$form, &$form_state) {
  $form['settings']['#collapsed'] = FALSE;
}

/**
 * Implementation of hook_form_alter().
 */
function webb_form_node_type_form_alter(&$form, &$form_state) {
/*
  $form['webb'] = array(
    '#type' => 'fieldset',
    '#title' => t('WeBB'),
    '#description' => t('WeBB-specific configuration.'),
  );
  */
}

/**
 * Implementation of hook_form_alter();
 */
function webb_form_user_edit_alter(&$form, &$form_state) {

  // Always make sure the contact form is enabled.
  $form['contact'] = array(
    '#type' => 'value',
    '#value' => 1,
  );
}

/**
 * Implementation of hook_form_alter();
 */
function webb_form_note_node_form_alter(&$form, &$form_state) {
  dpm(__FUNCTION__);

  if (empty($form['nid']['#value'])) {
    webb_set_og_context();
  }

  // Pre-fill the parent id field from the GET query, then hide it
  //$parent_nid = (int)$_GET['parent_nid'];
  $parent_nid = arg(3);
  //$form['field_parent_note'][0]['#type'] = 'value';
  if ($parent_nid) {
    
    $parent = node_load($parent_nid);
/*
    //Note 2 [nid:13]
    $form['field_parent_note'][0]['#value'] = "{$parent->title} [nid:{$parent->nid}]";
*/
    // Also set the default value of the note to the quoted version of the parent's body
    $body = &$form['body_field']['body'];
    dpm($body);
    if (! $body['#default_value']) {
      $parent = node_load($parent_nid);
      $body['#default_value'] = webb_quote_note($parent);
    }
  }

  // Hide and pre-fill the title field, since we don't want to use it
  // We'll fill in a "real" title in hook_nodeapi.
  $form['title']['#type'] = 'value';
  $form['title']['#value'] = 'Note';


/*
  // Set the options for the character to post as manually, because this is too complex to do via configuration.
  // We want all characters owned by the current user (or the user that posted the note if it's an edit), ordered
  // alphabetically.  The default character is whichever was most recently used.
  if (isset($_GET['gids'])) {
    $params = $_GET['gids'];
    global $user;
    $uid = $user->uid;
    $new_node = TRUE;
  }
  else {
    $node = $form['#node'];
    $params = $node->og_groups;
    $uid = $node->uid;
    $new_node = FALSE;
  }

  if (count($params)) { // This should only ever be false on the content type edit form, because CCK is weird and calls form_alter when it doesn't have to.
    $placeholders = implode(',', array_fill(0, count($params), '%d'));
    $params[] = $uid;
    $characters = db_fetch_assoc("SELECT n.nid, field_display_name_value
      FROM {node} n
        INNER JOIN {content_type_character} ctc ON n.vid=ctc.vid
        INNER JOIN {og_ancestry} oa ON ctc.nid=oa.nid
      WHERE oa.group_nid IN (" . $placeholders . ")
        AND n.uid=%d
      ORDER BY title", $params);
  }
  else {
    $characters = array();
  }
  $form['field_character']['nids']['#options'] = array(0 => t('<none>')) + $characters;
  if (count($characters)) {
    $placeholders = implode(',', array_fill(0, count($characters), '%d'));
    $default_character = db_result(db_query_range("SELECT ctn.field_character_nid
      FROM {node} n
        INNER JOIN {content_type_note} ctn on n.nid=ctn.nid AND n.vid=ctn.vid
      WHERE ctn.field_character_nid IN (" . $placeholders . ")
      ORDER BY n.created DESC", array_keys($characters), 0, 1));
    if ($new_node) {
      $form['field_character']['nids']['#default_value'] = array($default_character);
    }
  }
  else {
    $form['field_character']['nids']['#default_value'] = array(0);
  }
*/
}

/**
 * Helper function for form_alter for postable forms.
 */
function _webb_form_alter_postable_node_form(&$form, &$form_state) {

  // If the user isn't a site-admin, then we don't want to give them access to the OG-specific functionality.
  if (! user_access('administer site configuration')) {
    $form['title'] = array(
      '#type' => 'item',
      '#title' => $form['title']['#title'],
      '#value' => $form['title']['#default_value'],
      '#weight' => $form['title']['#weight'],
    );
    $form['og_selective'] = array(
      '#type' => 'value',
      '#value' => $form['og_selective']['#default_value'],
    );

    // Disable various OG fields that have no purpose.
    $form['og_register'] = array(
      '#type' => 'value',
      '#value' => $form['og_register']['#default_value'],
    );
    $form['og_directory'] = array(
      '#type' => 'value',
      '#value' => $form['og_directory']['#default_value'],
    );
    $form['og_private'] = array(
      '#type' => 'value',
      '#value' => $form['og_private']['#default_value'],
    );
  }
  $form['og_description']['#title'] = t('Slogan');
}

/**
 * Implementation of hook_form_alter().
 */
function webb_form_character_node_form_alter(&$form, &$form_state) {
  if (empty($form['nid']['#value'])) {
    webb_set_og_context();
  }

  // Rename the "Author" field and make it accessible to board admins, too.
  if ((isset($form['#node']->og_groups[0]) && _webb_is_og_admin($form['#node']->og_groups)) || _webb_is_og_admin(arg(1))) {
    $form['author']['#access'] = TRUE;
    $form['author']['#collapsed'] = FALSE;
    $form['author']['name']['#title'] = t('Owner');
    $form['author']['name']['#description'] = t('Specify the user that owns this character.');
    $form['author']['date']['#access'] = FALSE;
  }

  // First get the allowed positions for this Board.
  if (isset($form['#node']->nid) && $form['#node']->nid) {
    $ogs = $form['#node']->og_groups; // The character node's groups are already defined.
  }
  else {
    $ogs = array(arg(1)); // Use whatever the current OG is, since we'll be assigning to that anyway.
  }
}

function webb_form_logentry_node_form_alter(&$form, &$form_state) {
  if (empty($form['nid']['#value'])) {
    webb_set_og_context();
  }
}

/*
function webb_views_query_alter(&$query, &$view, $summary, $level) {

  if ($view->name == 'og_notes' && !empty($_SESSION['webb']['default_notes_filter_time'])) {

    $options = _webb_og_notes_filter_form_time_options($view);

    // If there is a filter specified in the GET query, that takes precedence.
    // Save that in the session for later use.
    if (!empty($_GET['filter1'])) {
      $default = check_plain($_GET['filter1']);
      $_SESSION['webb']['default_notes_filter_time'] = $options[$default];
    }

    // Because we're doing weird stuff to the query, it can't be cached.
    // This is already set, I think, but let's be sure.
    $view->is_cacheable = FALSE;

    // Technically this is not necessary as the used_filters have aleady been
    // parsed.  But we'll do it again anyway just for completeness.
    $view->used_filters['filter1'] = array_search($_SESSION['webb']['default_notes_filter_time'], $options);

    // 9 is a magic number.  It was determined via debugging.  This is ugly
    // and evil.  Index 9 is where the timestamp happens to be.  We don't need
    // to calculate the offset here, because that's already done in the query
    // (in index 10).
    $query->where_args[9] = strtotime($view->used_filters['filter1']);
  }
}
*/

/**
 * Helper function for form_alter for the og_nodes filter form.
 */
function _webb_form_alter_og_notes_filter_form($form_id, &$form) {

  $options = _webb_og_notes_filter_form_time_options($form['view']['#value']);

  // The default value for the select box is a timestamp, but we could get it
  // from any number of places.  The GET parameter has first priority, then
  // the session as set by hook_views_query_alter(), then the hard-coded default
  // of 1 week.
  if (!empty($_GET['filter1'])) {
    $default = check_plain($_GET['filter1']);
  }
  elseif (!empty($_SESSION['webb']['default_notes_filter_time'])) {
    $default = array_search($_SESSION['webb']['default_notes_filter_time'], $options);
  }
  else {
    $default = array_search('1 week', $options);
  }

  // Replace the existing textfield with our fancy select box.
  $form['filter1'] = array(
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => $default,
  );

  // We also need to completely change the values for the Location select box.  By default
  // it's set to a completely nonsense value because I have no idea how else to do it. :-)
  // Instead, we change it here to be the terms for the "Location" vocab in the current OG.
  // This is insanely ugly and ought to be fixed at some point.
  /*$og = og_get_group_context();
  dpm($og);
  $vid = key($og->og_vocabularies);
  $terms = _webb_taxonomy_get_terms($vid);*/
  //$form['filter0']['#options'] = array('**ALL**' => t('<All>')) + $terms;

}


/**
 * Returns an array of time offset options for the og_notes views filter form.
 *
 * @param $view
 *   The view object for which we want the possible options.
 */
function _webb_og_notes_filter_form_time_options($view) {
  // The view may have a default offset specified so that when no form is used actual
  // notes are shown.  We therefore compensate by subtracting that value from each option.
  // Since the exact time of the page load will vary, each option is midnight GMT the
  // specified time period ago.
  $offset = $view->filter[2]['options'];
  $times = array('1 day', '3 days', '1 week', '2 weeks', '1 month', '3 months', '1 year');
  $options = array();
  foreach ($times as $time) {
    $date = getdate(strtotime('-' . $time) - $offset);
    $options["{$date['year']}-{$date['mon']}-{$date['mday']} 0:0:0"] = t($time);
  }

  return $options;
}

/*------------------- Theme functions -------------------*/

function webb_theme($existing, $type, $theme, $path) {
  return array(
    'nodereference_character_select' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}


/**
 * Implementation of hook_profile_alter().
 */
function webb_profile_alter(&$account) {

  // We don't want to show the subscription list or the user's
  // original application.
  unset($account->content['Application']);
}

/**
 * Implementation of hook_views_tables().
 */
/*
function webb_views_tables() {
  $tables['webb_note_lookup'] = array(
    'name' => 'webb_note_lookup',
    'join' => array(
      'type' => 'inner',
      'left' => array(
        'table' => 'node',
        'field' => 'nid',
      ),
      'right' => array(
        'field' => 'nid',
      ),
    ),
    'sorts' => array(
      'created_lookup' => array(
        'field' => 'created',
        'name' => t('WeBB Note Lookup: Created Time'),
        'handler' => 'views_handler_sort_date',
        'option' => views_handler_sort_date_options(),
        'help' => t('Sort by the submission date of the node.'),
      ),
    ),
    'filters' => array(
      'created' => array(
        'name' => t('WeBB Note Lookup: Created Time'),
        'operator' => 'views_handler_operator_gtlt',
        'value' => views_handler_filter_date_value_form(),
        'handler' => 'views_handler_filter_timestamp',
        'option' => 'string',
        'help' => t('This filter allows nodes to be filtered by their creation date.')
          .' '. views_t_strings('filter date'),
      ),
    ),
  );

  return $tables;
}
 */

/**
 * Implemenation of hook_views_arguments().
 */
/*
function webb_views_arguments() {
  $args = array(
    'gid_lookup' => array(
      'name' => t("WeBB Note Lookup: Group nid(s)"),
      'handler' => 'webb_og_handler_argument_gid',
      'help' => t('Filter for the one or more organic groups. Groups should be specified as a comma or plus delimited list of node ids, like taxonomy URLs. '),
    ),
  );
  return $args;
}
*/

/*
function webb_og_handler_argument_gid($op, &$query, $argtype, $arg = '') {
  switch ($op) {
    case 'summary':
      og_handler_summary($fieldinfo, $query);
      return $fieldinfo;
    case 'link':
      if ($name = $query->title) {
        return l($name, "node/". intval($query->group_nid));
      }
      else {
        // return l(t('Unaffiliated'), "$arg/-1-1"); // just signifies 'no group'
        return t('All posts');
      }
      break;
    case 'sort':
      // no luck using add_orderby method.
      $query->orderby[] = ' num_nodes '. $argtype;
      break;
    case 'filter':
      webb_og_views_break_phrase($arg, $query);
      break;
    case 'title':
      return db_result(db_query_range('SELECT title FROM {node} WHERE nid = %d', $query, 0, 1));;
  }
}
*/

/*
function webb_og_views_break_phrase($string, &$query) {
  list($and_or, $gids) = _views_break_phrase($string);
  $and_or = strtoupper($and_or);
  // analogous to taxonomy AND/OR query. see views_taxonomy.inc

  if ($and_or == 'OR') {
      $query->ensure_table('webb_note_lookup');
      $cond = array_fill(0, count($gids), "{webb_note_lookup}.group_nid = %d");
      $query->add_where(implode(" $and_or ", $cond), $gids);
  }
  else {
    foreach ((array)$gids as $gid) {
      $query->ensure_table('webb_note_lookup');
      //$num = $query->add_table('webb_note_lookup');
      //$tablename = $query->get_table_name('webb_note_lookup', $num);
      $query->add_where("{webb_note_lookup}.group_nid = %d", $gid);
    }
  }

  if ($GLOBALS['current_view']->build_type == 'page' && is_numeric($gids[0])) {
    $node = node_load($gids[0]);
    og_set_group_context($node);
  }
}
*/

/* ---------- Move these elsewhere later --------------- */

/**
 * Returns the first column of a query result as an array.
 * Does not do a rewrite sql for you!
 * Call similar to db_query().
 */
function db_fetch_column($query) {
  $results = array();
  $args = func_get_args();
  array_shift($args);
  if (isset($args[0]) and is_array($args[0])) { // 'All arguments in one array' syntax
    $args = $args[0];
  }
  $res = db_query($query, $args);

  while ($row = db_fetch_array($res)) {
    $results[] = current($row);
  }

  return $results;
}

/**
 * Returns an associative array, with the first column of the result set
 * as the key and the second as the value.
 * Does not do a rewrite sql for you!
 * Call similar to db_query().
 */
function db_fetch_assoc($query) {
  $results = array();
  $args = func_get_args();
  array_shift($args);
  if (isset($args[0]) and is_array($args[0])) { // 'All arguments in one array' syntax
    $args = $args[0];
  }
  $res = db_query($query, $args);

  while ($row = db_fetch_array($res)) {
    $keys = array_keys($row);
    $results[$row[$keys[0]]] = $row[$keys[1]];
  }

  return $results;
}
